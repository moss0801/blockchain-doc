image::https://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/Public_key_encryption.svg/220px-Public_key_encryption.svg.png[]

암호화와 복호화에 같은 키를 사용하는 비밀키 암호화 기법과 달리, 암호화와 복호화에 사용하는 키가 서로 다른 암호화 방식을 의미한다.

**비대칭키 암호화**라고도 한다.

공개 키 암호 방식을 크게 두 가지 종류로 나눌 수 있다.

* **공개 키 암호** - 특정한 비밀 키를 가지고 있는 사용자만 내용을 열어 볼 수 있음.
* **공개 키 서명** - 특정한 비밀 키로 만들었다는 것을 누구나 확인할 수 있음

## 원리
공개키 암호화 방식은 출제자만이 알고 있는 특별한 종류의 정보(비밀키) 없이는 매우 풀기 어려운 수학적 문제(공개키)를 바탕으로 만들어진다.
키를 만드는 사람은 이 문제(공개키)를 일반에게 공개하고 특정한 정보(비밀키)는 자신만이 알 수 있도록 숨긴다.
그러면 어떤 사람이건 이 문제를 이용해 메시지를 암호화하면 키를 만든 사람만이 이 문제를 풀어 원래 메시지를 해독할 수 있다.

* 소인수분해(RSA): 2 개의 큰 소수를 곱하는 것은 아주 간단하다. 그러나 2개의 큰 소수의 곱의 소인수 분해는 어렵다.
* 이산 로그 문제(디피-헬만 키 교환, 타원 곡선 암호): stem:[a]와 stem:[c]가 알려진 상태에서 방정식 stem:[a^b = c]의 해 stem:[b]를 구하는 문제 +
순환군 ⟨g⟩와 군의 원시근(primitive root) g, 그리고 y∈⟨g⟩ 가 주어졌을 때, y=g^k^를 만족하는 최소의 자연수 k를 찾는 문제이다.
암호학에서는 큰 소수 p에 대해 p로 나눈 나머지들의 모임인 Z∗p를 사용하는 경우가 많다. +
** 타원 곡선 산술에서 소수로 나눈 나머지를 곱하는 것은 간단하지만, 나눗셈(역함수)은 사실상 불가능하다.

### 트랩도어 함수(trapdoor function, 비밀통로 일방향함수)
image::https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Trapdoor_permutation.svg/300px-Trapdoor_permutation.svg.png[]
일방향함수의 한 종류이다. 보통 일방향함수처럼 함수의 역을 구하는 것은 어렵지만, **트랩도어**라고 부르는 특수한 정보가 있으면 쉽게 역을 구할 수 있는 함수이다.

수학적으로 stem:[f]가 트랩도어 함수이면 stem:[f(x)]가 주어졌을 때, stem:[t](trapdoor)가 없으면 stem:[x]를 계산하기 어렵지만,
stem:[t]가 주어지면 쉽게 stem:[x]를 계산할 수 있습니다.

간단한 예는, 8,018,009(stem:[f(x)])가 소수 2개의 곱이라 할 때, 소인수를 찾는 문제는 어렵다.
하지만 소인수 중 하나가 2,003(stem:[t])이라는 것을 안다면, 나머지 소인수 4,003(stem:[x])(8,018,009 ÷ 2,003 = 4,003)를 쉽게 계산할 수 있다.

현재까지 가장 널리 알려진 트랩도어 함수의 후보는 RSA와 라빈 함수들이다.
이 함수들 모두 합성수에 대한 모듈로 거듭제곱(modulo exponentiation)을 사용하며, 소인수 분해의 어려움에 기반하고 있다.

이산로그 문제에 기반한 모듈로 소수 또는 타원곡선의 트랩도어 함수는 알려진 것이 없다.
아직까지 이산로그를 효율적으로 계산할 수 있는 트랩도어를 찾지 못했기 때문이다.

## 주요 공객키 암호화 방식
### 디피-헬만 키 교환(Diffie–Hellman key exchange)
1976년 마틴 헬먼(Martin Hellman)과 휫필드 디피(Whitfield Diffie)이 랄프 머클(Ralph Merkle) 공개 키 분배에 대한 연구를 참고하여 공개한 디피-헬만 키 교환(Diffie–Hellman key exchange) 알고리즘을 대중에게 공개했다.
이는 최초로 발표된 (일종의) 공개키 암호화 방식이다.
하지만 엄밀히 말하면 이는 단순히 키 교환 알고리즘일 뿐이므로 암호화/복호화에 대한 내용은 없다.
하지만 인증된 (그러나 공개된) 통신 채널상에서 미리 키를 공유하지 않으면서도 공유 보안 키를 설정할 수 있는 최초의 실용적인 방법이었다.

#### 방식
앨리스와 밥이 공개된 통신망에서 디피-헬먼 키 교환을 하기 위해서는 다음과 같은 절차를 거친다.

1. 앨리스가 소수 stem:[p], 그리고 stem:[1]부터 stem:[p-1]까지의 정수 stem:[g]를 선택하여 사전에 밥과 공유한다.
2. 앨리스가 정수 a를 선택한다. 이 정수는 외부에 공개되지 않으며, 밥 또한 알 수 없다.
3. 앨리스가 stem:[A = g^a mod p], 즉 stem:[g^a]fmf stem:[p]로 나눈 나머지를 계산한다.
4. 밥이 마찬가지로 정수 b를 선택하여 stem:[B = g^b mod p]를 계산한다.
5. 앨리스와 밥이 서로에게 stem:[A]dhk stem:[B]를 전송한다.
6. 앨리스가 stem:[B^a mod p]를, 밥이 stem:[A^b mod p]를 계산한다.

마지막 단계에서 stem:[B^a mod p = (g^b)^a mod p = g^(ab) mod p], stem:[A^b mod p = (g^a)^b mod p = g^(ab) mod p]이며 따라서 앨리스와 밥은 stem:[g^(ab) mod p]라는 공통의 비밀 키를 공유하게 된다.

앨리스와 밥 이외의 인물은 a와 b를 알 수 없으며, stem:[g], stem:[p], stem:[g^a mod p], stem:[g^b mod p]를 알 수 있다.

여기서 stem:[p]가 충분히 클 경우, stem:[g^a]와 stem:[g^b]를 통해서 stem:[g^(ab) mod p]를 알아낼 수 없는 것으로 알려져 있다.

그러나 stem:[p]나 stem:[a], stem:[b]가 너무 작을 경우, 가능한 모든 조합을 다 계산해보는 방식으로 stem:[g^(ab) mod p]를 계산해낼 수 있다. 만약 stem:[p]가 최소 300자리의 소수이고, stem:[a], stem:[b]가 각각 100자리 이상의 정수일 경우, 공개된 정보로부터 비밀 키를 알아내기는 매우 어렵다.

### RSA Key Cryptosystem

공개키 암호화시스템의 하나로, 암호화뿐만 아니라 전자서명이 가능한 최초의 알고리즘으로 알려져 있다.

1977년 로널드 라이베스트(Ron **R**ivest), 아디 샤미르(Adi **S**hamir), 레너드 애들먼(Leonard **A**dleman)의 연구에 의해 체계화 되었으며, RSA라는 이름은 이들 3명의 이름 앞글자를 딴 것이다.

RSA 암호체계의 안정성은 큰 숫자를 소인수 분해하는 것이 어렵다는 것에 기반을 두고 있다.

이 알고리즘은 두 개의 큰 소수(보통 140자리 이상의 수)를 이용한다.
이 수들의 곱과 추가연산을 통해 하나는 공개키를 구성하고 다른 하나는 개인키를 구성하는데, 사용되는 두 세트의 수 체계를 유도하는 작업이 수반된다.

#### 키생성 (나무위키)
1. 두 소수 stem:[p], stem:[q]를 준비한다.
2. stem:[p-1], stem:[q-1]과 각각 서로소 인 정수 stem:[e]를 준비한다.
** 서로소: 여러 개들의 수들 사이에서 1 이외의 공약수가 없음을 이르는 말
** stem:[e]는 **e**ncryiption의 e이다.
** 공개키는 비교적 선택이 자유롭기에 보통 1의 비트가 2개인, 3(11)이나 65537(10000000000000001) 같은 소수를 쓴다. 물론 (p - 1)(q - 1)와 서로소인 걸로만.
3. stem:[ed]를 stem:[(p-1)(p-1)]으로 나눈 나머지가 1이 되도록 하는 stem:[d]를 찾는다.
** stem:[d]는 **d**ecryption의 d이다.
** 확장된 유클리드 호제법을 이용하면 금방 구할 수 있다.
** e가 (p - 1)(q - 1)와 서로소가 아니라면 이를 만족하는 d는 존재하지 않기 때문에 2번 과정이 필요하다.
4. stem:[N = pq]를 계산한 후, stem:[N]과 stem:[e]를 공개한다. 이들이 바로 공개키이다. 한편 stem:[d]는 숨겨두는데, 이 수가 바로 개인키이다.
5. 이제 stem:[p], stem:[q], stem:[(p-1)(q-1)]는 필요 없거니와 있어 봐야 보안에 오히려 문제를 일으킬 수 있으니, 파기한다.
** stem:[p]와 stem:[q]가 있으면 공개키<N, e>와 비밀키<N, d> 계산이 가능하다.
** stem:[φ()]: 오일러 피(파이) 함수
** stem:[φ(pq)] = stem:[(p-1)(q-1)]

stem:[N]을 계수라 부르고 stem:[e]를 지수라고 부르는데 stem:[e]는 주로 65537(0x10001)을 사용한다.
RSA의 키 사이즈를 말할 때 주로 N의 사이즈를 의미하며 사이즈가 2048일 경우라면 정수 N의 크기가 2^2047^과 2^2048^의 사이라는 의미다.

한편 소수 stem:[p]와 stem:[q]를 구하는 과정은 여전히 완전한 방법이 없다고 봐야 한다.
일단 link:https://namu.wiki/w/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%20%EC%B2%B4[에라토스테네스의 체]를 이용한 방식을 생각해 볼 수 있는데 stem:[\sqrt{p}]보다 작은 소수들 모두로 나눠 봐야 알 수 있다는 점에서 이 방법은 현실적으로 불가능한 방법이다. 그래서 대신에 확률적으로 소수인지 아닌지를 판별하는 방법을 쓴다. 기본적으로 쓰는 방식이 아래에 소개할 페르마 소정리를 근거로 한 것인데, 이 정리의 대우명제인 '임의의 정수 stem:[a]에 대해 stem:[a^(p-1)]를 stem:[p]로 나눈 나머지가 1이 아니면 stem:[p]는 소수가 아니다'라는 사실을 이용한 것이다. 이 방법을 쓰면 상당 확률로 소수를 걸러낼 수 있다고 한다. 하지만 물론 완전하진 않으며 이 때문에 다른 소수 판정법을 같이 쓰기도 한다.

#### 키생성 (위키백과)
p와 q라고 하는 두 개의 서로 다른 stem:[p != q] 소수를 고른다.
1. 두 수를 곱하여 stem:[N = pq] 을 찾는다.
2. stem:[φ(N) = (p-1)(q-1)] 를 구한다.
3. stem:[φ(N)] 보단 작고, stem:[φ(N)]와 서로소인 정수 stem:[e]를 찾는다.
4. 확장된 유클리드 호제법을 이용하여 stem:[e × e] 를 stem:[φ(N)]로 나누었을 때 나머지가 1인 정수 d를 구한다.(stem:[de \equiv 1  (mod φ(N))])

#### 암호화
평서문 stem:[a]를 stem:[x \equiv a^e (mod N)]으로 암호화 한다. (여기서 stem:[a < N]이어야 한다.)

* 만약 보내려는 평서문의 길이가 N보다 길면, 모종의 복잡한 변환법을 통해 분할하여 N보다 짧게 만든다. 당연하지만 해당 변환법은 보내는 측과 받는 측 모두 알고 있어야 한다.
* stem:[x \equiv a^e (mod N)] 는 stem:[x]를 stem:[N]으로 나눴을 때 나머지가 stem:[a^e]가 된다는 뜻이다. stem:[mod]는 나머지 연산(모듈러 연산)을 의미한다.

#### 복호화

암호문 stem:[x]는 stem:[a′ \equiv x^d (mod N)] 으로 복호화한다.

이 때 stem:[a′ = a]가 성립하여 평서문을 얻을 수 있다.

### 타원 곡선 암호(ECC; Elliptic curve cryptography)

타원 곡선 군의 연산에서 정의되는 이산대수 문제의 어려움에 기반한 공개키 암호 방식이다. 줄여서 **ECC**라고 쓰기도 한다.
1985년에 닐 코블리츠(Neal Koblitz)와 빅터 밀러(Victor Miller)가 각각 독립적으로 제안했다.
아직까지 해독 방법은 발견되지 않았다.

기본 공개키 암호 방식(RSA/DSA/Rabin/ElGamal)에 비하여 갖는 장점은 짧은 키 길이와 빠른 연산속도를 가지면서 동일한 수준의 보안 강도를 제공한다.
예를 들어 256bit 타원 곡선 공개키는 3072bit RSA 공개키와 유사한 보안 강도를 제공합니다.

.NIST Recommended Key Sizes
[cols="1,1,1"]
|===
|Symeetric Key Size(bits)|RAS and Diffie-Hellman Key Size(bits)|Elliptic Curve Key Size(bits)

|80|1024|160
|112|2048|224
|128|3072|256
|182|7680|384
|256|15360|521
|===

## 용도
### 기밀 내용의 전달
A가 자신만 알고 있는 기밀을 B 에게 전달하고자 할 때 사용한다. B 를 제외한 타인은 이 내용을 알 수 없어야 한다.

1. B 가 자신의 공개키를 공개한다.
2. A 는 이 공개키로 문서를 암호화 한다.
3. 암호화된 문서를 B 에게 전달한다.
4. B 는 자신만이 가진 개인키로 이 문서를 해독한다.

타인이 전달과정에서 암호화된 문서를 가로채더라도 B의 개인키가 없으면 해독이 불가능하다

link:https://namu.wiki/w/TLS[SSL/TLS]에서 두 당사자가 사용할 '대칭키'를 전달하는 용도로 사용된다.

다만 공개키 암호화는 처리 속도가 매우 느림으로 공개키 암호화는 TLS의 키 교환 같이 간단한 데이터를 전달하는 용도로만 사용된다.

### 발행자의 증명 및 문서의 변조 방지

어떤 문서를 '자신이 작성했음'을 증명하는 용도로도 사용될 수 있다.
오래전부터 발행자의 증명은 인장, 도장, 서명 등의 방법이 사용되었으나, 이는 모두 위조가 가능하다.
게다가, 문서의 변조를 막을 수도 없다.

1. A 는 자신의 공개키를 공개한다.
2. A 는 어떤 문서를 자신의 개인키로 암호화 한다.
3. A 는 암호화된 문서를 일반에 공개하면서,이 문서를 자신이 만들었음을 선포한다.
4. 타인은 공개된 공개키로 해당 문서를 해독하여 내용을 볼 수 있다.

타인은 A의 공개키로 복호 가능한 문서를 생성할 수 없으므로, 해당 문서는 A 만이 발행 할 수 있다는 강력한 증거가 된다.

추가로, 해당 문서가 **변조되지 않았다**라는 중요한 기능을 동시에 얻을 수 있다.

이는 공인인증서를 비롯한 전자서명에서 사용되는 방법이다.

### 부인 방지
B가 가지고 있는 어떤 문서에 A 의 서명 (또는 도장)이 있는데, 정작 A 는 이 서명이 자신의 것이 아니라고 부인할 수 있다.
B 는 문서에 있는 서명이 A 의 것이 맞다는 것을 확인하는 것이 '부인 방지'이다.
공개키 암호화 방식에서는 본질적으로 '발행자의 증명'과 동일한 절차로 이루어진다.

1. B 는 A 에게 개인키/공개키를 생성한 뒤 공개키를 공개하도록 요구한다.
2. B 는 A 에게 '문서'를 개인키로 암호화할 것으로 요구한다.
3. B 는 이 '암호화된 문서'를 수령한다.
4. B 는 '암호화된 문서'를 A 의 공개키로 해독하여, 이 문서가 A 의 개인키로 제대로 암호화 되었음을 검증할 수 있다.

이 '암호화된 문서'는 A 의 공개키로만 해독이 가능하므로, 이 '암호화된 문서'는 A 만이 발행할 수 있다는 증거가 된다.
또한, 변조되지 않았음도 동시에 증명할 수 있다.


## Reference
* 공객키 암호 방식
** link:https://ko.wikipedia.org/wiki/%EA%B3%B5%EA%B0%9C_%ED%82%A4_%EC%95%94%ED%98%B8_%EB%B0%A9%EC%8B%9D[위키백과 - 공개 키 암호 방식]
** link:https://namu.wiki/w/%EA%B3%B5%EA%B0%9C%ED%82%A4%20%EC%95%94%ED%98%B8%ED%99%94%20%EB%B0%A9%EC%8B%9D[나무위키 - 공개키 암호화 방식]
* link:https://nyan101.github.io/blog/algorithms-for-discrete-logarithm-problem[이산 로그 문제(DLP)에 대한 알고리즘(Shanks, Pollard-rho, Pohlig-Hellman)]
* link:https://ko.wikipedia.org/wiki/%EB%94%94%ED%94%BC-%ED%97%AC%EB%A8%BC_%ED%82%A4_%EA%B5%90%ED%99%98[위키백과 - 디피 헬먼 키 교환]
* RSA 암호
** link:https://ko.wikipedia.org/wiki/RSA_%EC%95%94%ED%98%B8[위키백과 - RSA 암호]
** link:https://namu.wiki/w/RSA%20%EC%95%94%ED%98%B8%ED%99%94[나무위키- RSA 암호화]
* 타원곡선암호
** link:http://wiki.hash.kr/index.php/%ED%83%80%EC%9B%90%EA%B3%A1%EC%84%A0%EC%95%94%ED%98%B8[해시넷 - 타원곡선암호]
** link:https://ko.wikipedia.org/wiki/%ED%83%80%EC%9B%90%EA%B3%A1%EC%84%A0_%EC%95%94%ED%98%B8[위키백과 - 타원곡선 암호]
* 마스터링 이더리움 - 04 암호학
** link:https://en.wikipedia.org/wiki/Cryptography[암호학(Cryptography)]
** link:https://en.wikipedia.org/wiki/Trapdoor_function[트랜도어 함수(Trapdoor function)]
** link:https://en.wikipedia.org/wiki/Integer_factorization[소인수 분해(Integer factorization)]
** link:https://en.wikipedia.org/wiki/Discrete_logarithm[이산 로그(Discrete logarithm)]
** link:https://en.wikipedia.org/wiki/Elliptic-curve_cryptography[타원 곡선 암호화(Elliptic-curve cryptography]
